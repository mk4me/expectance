%Autor: Marek Kulbacki, Artur Bak

\documentclass[12pt,a4paper]{article}
%-- header poczatek ------------------------------------------------
\usepackage[textwidth=16cm, textheight=24cm, centering]{geometry}
\usepackage[colorlinks=true, linkcolor=blue, hyperindex, bookmarksopen]{hyperref} 
\usepackage{color} 
\usepackage{graphicx}	

\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\frenchspacing 
\sloppy
%-- header koniec --------------------------------------------------

%-- dokument poczatek ----------------------------------------------
\begin{document}

\begin{titlepage}
 
\begin{center}
\vfill
\vspace*{5 cm}
\includegraphics[width=0.5\textwidth]{./img/ft_logo.png}\\[1cm]
\vspace*{2 cm}
 
\textsc{\huge \textbf{Generator}}\\[1.5cm]
 
\textsc{\Large dokumentacja analityczna}\\[0.5cm]
 
 
 \vfill
\end{center}
% Author and supervisor
\begin{flushleft} \small
Wersja: 0.6 \\
Data modyfikacji: \today \\
Autorzy: A.\textsc{B¹k} and M.\textsc{Kulbacki}\\
\end{flushleft}
% Bottom of the page

\end{titlepage}



\tableofcontents

\vspace*{2ex}
\hrule

\section{Model aplikacji Generator'a}
Aplikacja Generator'a bazuje na dwóch g³ównych bibliotekach: 
\\
- GLUT – u¿ywana do zarz¹dzania aplikacj¹ okienkow¹ oraz podstawowych operacji graficznych
\\
- Cal3d – u¿ywana do reprezentacji modeli avatarów oraz zarz¹dzanie animacjami dla nich
\\

Do szybkiego ustawiania parametrów aplikacji oraz jej sk³adowych modu³ów s³u¿y plik \textit{/data/application.cfg}.
Modele avatarów oraz animacje dla nich opisane s¹ w standardowym formacie modeli Cal3d (pliki xsf/xaf/xmf/xrf  lub csf/caf/cmf/crf opisane skryptami \textit{*.cfg)}.
\\

Ogólna ilustracja struktury aplikacji Generator'a zosta³a przedstawiona na rysunku \ref{rys_0}.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/generator_app.png}
  \end{center}
  \caption{Struktura aplikacji Generator'a}
  \label{rys_0}
\end{figure}

\subsection{Konfiguracja aplikacji}
Konfiguracja aplikacji znajduje siê w pliku tekstowym \textit{/data/application.cfg}. Format zapisu jest bardzo prosty i wyró¿nia dwie podstawowe instrukcje:
\begin{enumerate}
\item \textbf{komentarz} - umieszczony jest w linii zaczynaj¹cej siê znakiem\textbf{\#}.
\item \textbf{definicja parametru} - linia sk³adaj¹ca siê z trzech jednostek leksykalnych:
\begin{enumerate}
\item \textbf{identyfikatora} parametru (l-wartoœci)
\item operatora przypisania (\textbf{=})
\item \textbf{wartoœci} lub \textbf{zbioru wartoœci} (r-wartoœci) 
\end{enumerate} 
\end{enumerate}
Definicje parametrów pogrupowane s¹ w sekcjach. Ka¿da sekcja rozpoczyna siê nag³ówkiem w formie komentarza. Definicja parametru mo¿e przyjmowaæ dwie formy:
\begin{enumerate}
\item \textbf{\textit{identyfikator parametru} = \textit{wartoœæ}}
\item \textbf{\textit{identyfikator parametru} = (\textit{wartoœæ1, wartoœæ2, \ldots, wartoœæ-n})}
\end{enumerate}

\subsubsection{Tworzenie wybranych parametrów}

\textbf{Tworzenie menu}
Menu jest struktur¹ drzewiast¹ omówion¹ dok³adnie w rozdziale dotycz¹cym typu \textit{ft:MenuManager}. Menu buduje siê w dwóch krokach, które mo¿na cyklicznie powtaraæ:
\begin{enumerate}
\item zdefiniowanie menu g³ównego z list¹ parametrów : \textit{identyfikator\_menu = (lista identyfikatorów\_parametrów\_menu oddzielonych przecinkami)}
\item zdefiniowanie ka¿dego prametru menu g³ównego w postaci: \textit{identyfikator\_parametru menu = (etykieta informacyjna, nazwa tekstury)}
\end{enumerate}

\textbf{Tworzenie definicji konfiguracji kamer}
Definicja konfiguracji kamer jest dwuetapowa. W pierwszym kroku tworzy siê listê definicji w formacie: \textit{identyfikator = (lista identyfikatorów konfiguracji kamer oddzielona przecinkami)}. W drugim kroku dla ka¿dego identyfikatora konfiguracji kamery przypisuje siê nastêpuj¹ce parametry:
\begin{enumerate}
\item \textit{Hot\_key} - klawisz, który uruchamia dan¹ konfiguracjê kamery. Dostêpne wartoœci: \textit {ft\_F1, ft\_F2, ft\_F3 ,ft\_F4, ft\_F5 ,ft\_F6, ft\_F7, ft\_F8, ft\_F9, ft\_F10, ft\_F11, ft\_F12, ft\_KEY\_LEFT, ft\_KEY\_UP, ft\_KEY\_RIGHT, ft\_KEY\_DOWN, ft\_KEY\_PAGE\_UP, ft\_KEY\_PAGE\_DOWN, ft\_KEY\_HOME, ft\_KEY\_END, ft\_KEY\_INSERT}.
\item \textit{Typ kamery} - zdefiniowany w systemie typ kamery. Dostêpne wartoœci: \textit{ft\_ActiveAvatarCamera, ft\_MainCamera}.
\item \textit{Tryb pracy kamery} - mo¿na go wybraæ z listy czterech dostêpnych trybów pracy. Dostêpne wartoœci: \textit{ft\_StaticCamera, ft\_ThirdPersonCamera, ft\_FlyCamera, ft\_OrbitCamera}.
\item \textit{Lokalizacja} - orientacja kamery wzglêdem punktu, na który kamera "patrzy". Dostêpne wartoœci: \textit{ft\_FrontLeft, ft\_FrontCenter, ft\_FrontRight, ft\_Left, ft\_Center, ft\_Right, ft\_BackLeft, ft\_BackCenter, ft\_BackRight, ft\_TopFrontLeft, ft\_TopFrontCenter, ft\_TopFrontRight, ft\_TopLeft, ft\_TopCenter, ft\_TopRight, ft\_TopBackLeft, ft\_TopBackCenter, ft\_TopBackRight, ft\_BottomFrontLeft, ft\_BottomFrontCenter, ft\_BottomFrontRight, ft\_BottomLeft, ft\_BottomCenter, ft\_BottomRight, ft\_BottomBackLeft, ft\_BottomBackCenter, ft\_BottomBackRight, ft\_AutoLocation}.
\end{enumerate}

\section{Modu³ UpdateManager}
Modu³ UpdateManager jest jednym z bazowych modu³ów Generatora.  Do jego g³ównych zadañ nale¿y odœwie¿anie obiektów w ka¿dej klatce symulacji (frame) oraz rozsy³anie wiadomoœci do zainteresowanych obiektów.

G³ówn¹ klas¹ modu³u jest \textit{UpdateManager}, która posiada tylko jedn¹ instancjê (Singleton).  

Aby obiekty mog³y byæ odœwie¿anie przez \textit{UpdateManagera} lub odbieraæ wiadomoœci musz¹ byæ pochodnymi klasy \textit{UpdateObject} oraz byæ zarejestrowanie w UpdateManager'ze.

\subsection{Odœwie¿anie obiektów}
Aby dany obiekt  móg³ reagowaæ na odœwie¿enie w ka¿dej klatce animacji powinien pokryæ metodê \textit{OnUpdate (float elapsedTime)} z klasy bazowej UpdateObject.  Parametr \textit{elapsedTime} okreœla ile czasu minê³o od poprzedniego odœwie¿enia. UpdateManager bêdzie wywo³ywa³ metodê \textit{OnUpdate} na wszystkich zarejestrowanych obiektach zgodnie z parametrami okreœlonymi dla aktualnej symulacji (klasa \textit{ft::Simulation}). Klasa \textit{ft::Simulation} odczytuje czas przy pomocy metody \textit{getTick()}. W zale¿noœci od potrzeby mo¿na pobieraæ czas z dok³adnoœci¹ do mili albo mikrosekund.
\subsection{Rozsy³anie wiadomoœci}
UpdateManager rozsy³a wiadomoœci do zarejestrowanych obiektów za pomoc¹ obiektów klasy \textit{ft::Message}.  Wywo³uje w tym celu na obiektach funkcje \textit{OnMessage(Message* msg)}, która jest zdefiniowana w klasie \textit{UpdateObject}. Aby obiekt móg³ zareagowaæ na wiadomoœæ powinien on pokryæ metodê \textit{OnMessage} i zaimplementowaæ w niej rozpoznanie typu wiadomoœci oraz odpowiednie akcje.

Ka¿dy obiekt w systemie mo¿e wys³aæ wiadomoœæ przez UpdateManager'a u¿ywaj¹c metody \textit{SendMessage(Message* msg, bool deleteAfterSent)}.  Jako parametr \textit{msg} nale¿y podstawiæ w³aœciwy obiekt typu \textit{Message}, natomiast \textit{deleteAfterSend} okreœla czy UpdateManager ma zwolniæ pamiêæ dla obiektu \textit{msg} po rozes³aniu go do zarejestrowanych obiektów.

Ilustracja przep³ywu sterowania podczas rozsy³ania wiadomoœci znajduje siê na rysunku \ref{rys_1}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/controlManager.png}
  \end{center}
  \caption{Przesy³anie wiadomoœci miêdzy obiektami implementuj¹cymi interfejs wiadomoœci UpdateManagera}
  \label{rys_1}
\end{figure}


\section{Avatar'y}
Podstawow¹ klas¹ reprezentuj¹c¹ animowan¹ postaæ jest Avatar. Mo¿na go dodawaæ do sceny oraz wykonywaæ na nim animacje. Obiekty typu Avatar bazuj¹ na modelach postaci z API Cal3d i mo¿na je traktowaæ jako odpowiedniki takich modeli z rozszerzona funkcjonalnoœci¹ na potrzeby Generatora.
\subsection{Powi¹zania Avatar'ów z modelami w API Cal3D}
Podstawowym bytem reprezentuj¹cym animowan¹ postaæ w API Cal3Dd jest obiekt CalModel. Obiekt CalModel mo¿e byæ utworzony na podstawie odpowiedniego typu. Definicj¹ takiego typu w Cal3d jest  obiekt CalCoreModel. 

Ró¿nica pomiêdzy CalCoreModelem i CalModelem jest taka, ze CalCoreModel zawiera definicje mesh'y, animacji, materia³ów oraz szkieletu postaci. CalModel jest natomiast specyficzna instancj¹ CalCoreModelu i mo¿na go ustawiaæ na scenie oraz wykonywaæ na nim animacje. Dla ka¿dego takiego typu mo¿e istnieæ dowolna iloœæ obiektów klasy CalModel.

Dla ka¿dego utworzonego obiektu klasy Avatar utworzony zostaje osobny obiekt  klasy CalModel w enginie Cal3d.   Ponadto obiekt Avatar zawiera referencjê do odpowiedniego obiektu CalCoreModel, na którego podstawie zosta³ utworzony jego CalModel. Dziêki temu z poziomu Avatar'a mo¿na odwo³ywaæ siê do definicji postaci.

Na rysunku \ref{rys_2} znajduje siê ilustracja przyk³adowej struktury modeli.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/modelCal3D.png}
  \end{center}
  \caption{Ilustracja przyk³adowej struktury modeli opartych na Cal3D}
  \label{rys_2}
\end{figure}

\subsection{Tworzenie avatarów}
Aby utworzyæ obiekt Avatar nale¿y wczeœniej utworzyæ dla niego odpowiedni obiekt CalModel w Cal3d oraz u¿yæ do tego odpowiedniego typu, czyli obiektu CalCoreModel.  Obiekt CalCoreModel tworzony jest na podstawie pliku konfiguracyjnego w formacie Cal3d (.cfg).  Nalezy przy tym pamiêtaæ, ¿e ten dany typ reprezentowany przez obiekt CalCoreModel wystarczy utworzyæ (wczytaæ z pliku .cfg) tylko jeden raz.  Nastêpnie mo¿na go u¿ywaæ do tworzenia dowolnej iloœci obiektów klasy CalModel.

Po utworzeniu danego obiektu CalCoreModel na podstawie pliku .cfg nale¿y dla niego zainicjowaæ materia³y. Z kolei po utworzeniu obiektu CalModel nale¿y odpowiednio zainicjowaæ meshe na podstawie CalCoreModelu. Powy¿sze operacje nale¿y wykonaæ w odpowiedniej kolejnoœci.

Aby uproœciæ tworzenie obiektu Avatar oraz jego relacji z modelami Cal3d zosta³a utworzona klasa   AvatarFactory.  Wystarczy wywo³aæ metodê  AvatarFactory.CreateAvatar() oraz zadaæ nazwê dla CalCoreModel'u (która odpowiada nazwie pliku .cfg) oraz dowoln¹ nazwê dla Avatar.  Ca³a operacja tworzenia Avatara odbywa siê wewn¹trz tej metody.

Dodatkowo  klasa AvatarFactory zapewnia zarz¹dzanie CalCoreModel'ami, tak aby ka¿dy osobny typ nie zosta³ utworzony wiêcej ni¿ jeden raz, nawet gdy odwo³amy siê do niego wiele razy

\subsection{Przechowywanie ruchów (animacji) dla Avatarów}
Animacje dla avatarów s¹ reprezentowane przez obiekty klasy \textit{Motion}. S¹ one kolekcjonowane w klasie \textit{MovableAvatar}, która jest pochodn¹ klasy \textit{Avatar}. Jeden obiekt klasy \textit{Motion} powi¹zany jest z dok³adnie jednym obiektem klasy \textit{CalCoreAnimation} w enginie Cal3d.  Animacja CalCoreAnimation jest w Cal3d sk³adow¹ CalCoreModel'u i jest wykonywana przez odpowiednie CalModel'e. 

Ilustracja struktury powi¹zañ dotycz¹cych animacji znajduje sie na rysunku \ref{rys_3}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{./img/coreModelAvatar.png}
  \end{center}
  \caption{Powi¹zania struktur dotycz¹cych animacji w Cal3D i Generatorze}
  \label{rys_3}
\end{figure}

\section{Warstwy logiczne avatara}

Strukture avatara mo¿na podzielic na kilka warstw logicznych. Hierarchia w kodzie tych warst zostala przedstawiona na rys \ref{rys_4}. W okolejnych podrozdzialach zostaly przedstana na rysunku X. W kolejnych podrozdzialach zostania opisane funkcjonalnosci jakie jest zwiazane z poszczegolnymi warstwami.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{./img/avatar_layers.png}
  \end{center}
  \caption{Warstwy logiczne avatara}
  \label{rys_4}
\end{figure}

\subsection{Warstwa danych 'Motion Capure'}

Dane ruchów uzywane  przez Generator to dane motion capture skonwertowane do formatu Cal3d. Tylko w takim formacie dane te sa widoczne z modu³ów Generatora (nie ma mozliwosci dostêpu do oryginalnego formatu zawartego w plikach motion capture - np. BVH).

\subsection{Warstwa animacji Cal3d}

Dane ruchu uzywane w Generatorze maja forme animacji Cal3d. Odgrywanie ruchów polega na odgrywaniu tych animacji przez API zdefinowane przez engine Cal3d. Dostep do szczego³owych danych dla poszczególnych koœci polega na pobieraniu œcie¿ek animacji (tzw track-ów) z animacji Cal3d.  Œcie¿ki te s¹ parametryzowane czasem - mo¿na wyci¹gn¹æ dowoln¹ klatkê animacji zadaj¹c odpowiedni czas t z zakresu od 0 do d³ugoœci (czasu trwania) tej animacji.  Dla poœrednich wartosci czasu t, które nie maja zdefiniowanych wartoœci w œcie¿ce, klatki sa wyliczane z u¿yciem interpolacji pomiêdzy najblizszymi zdefiniowanymi klatkami w œcie¿ce.

\subsection{Warstwa TimeLine'ów}

TimeLine'y u¿ywane s¹ do wygodnego definiowania œcie¿ki ruchu. Mo¿na tworzyæ z³o¿one ruchy, definiowaæ blending pomiêdzy nimi a tak¿e definiowaæ specjalne modyfikatory, w których oryginalne dane ruchu mog¹ byæ modyfikowane w kolejnych krokach symulacji.

\subsection{Warstwa 'Physics modifiers'}

W warstwie tej przewidziane jest tworzenie modyfikatorów, które dostosowuj¹ zdefinowan¹ TimeLine'ami sekwencje ruchów aby poprawiæ realizm i podtrzymanie poprawnoœci fizycznych aspektów ruchu np. eliminacja œlizgania siê stóp po pod³odze, poprawne stawianie kroków podczas skecania lub wykorzystanie kinematyki odwrotnej.

\subsection{Warstwa 'Control'}

Warstwa 'Control' ma zapewniæ mo¿liwoœc definiowania akcji oraz powi¹zañ pomiêdzy akcjami na wy¿szym poziomie ni¿ sama definicja sekwencji ruchu. Akcje mog¹ byæ wykonywane zgodnie ze zdarzeniami pochodz¹cymi od u¿ytkownika lub zgodnie z algorytmami sztucznej inteligencji w warstwach wy¿szych.

\subsection{Warstwa 'Think'}

W warstwie 'Think' przewidziana jest implementacja algorytmów sztucznej inteligencji, któe wprowadzaj¹ autnomiczne i inteligentne zachowanie avatarów np.: omijanie przeszkód czy  wyznaczanie œciezki do celu.

\section{Sterowanie ruchem – TimeLine'y}
Idea sterowania ruchem bazuje na pojêciu TimeLine'ow. TimeLine mo¿na traktowaæ jako œcie¿kê animacji, któr¹ avatar ma za zadanie wykonaæ. TimeLine reprezentowany jest przez obiekty typu \textit{ft::TimeLine}.

Zadany do wykonania TimeLine jest wype³niony obiektami typu \textit{ft::TimeLineMotion}. Obiekty typu TimeLineMotion maj¹ wskazania na animacje, które s¹ wykonywane przez avatar'a w trakcie wykonywania danego TimeLineMotion'a na œcie¿ce animacji.

Pomiêdzy kolejnymi obiektami TimeLineMotion mog¹ byæ zdefiniowane regu³y ³¹czenia. Regu³y ³¹czenia s¹ reprezentowane przez obiekty typu \textit{ft::TimeLineBlender}.

Podczas wykonywania TimeLineMotion'a, ruch avatara mo¿e byæ modyfikowany w dowolny sposób przez jeden lub kilka modyfikatorów ruchu. Ka¿dy modyfikator jest opisany w obiekcie typu \textit{ft::TimeLineModifier}.
\\

Za wykonywanie TimeLine'ow odpowiedzialne sa obiekty typu typu \textit{ft::TimeLineExecutor}. Kazdy avatar posiada jeden obiekt typu \textit{ft::TimeLine} 
oraz jeden obiekt typu \textit{ft::TimeLineExecutor}. Aby rozpoczac wykonywanie TimeLine'a przypisanego do danego avatara nalezy wywolac metode \textit{Start()}
na TimeLineExecutor'ze tego avatara. Po wywo³aniu tej metody rozpoczyna siê wykonywania kolejno wszystkich elementów (ruchów) sk³adowych TimeLine'a.

\subsection{Struktura TimeLine'a oraz relacje pomiêdzy jego sk³adowymi elementami}
 
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/timeLine.png}
  \end{center}
  \caption{Przep³yw informacji w obrêbie zdefiniowanego timeline-a}
  \label{rys_5}
\end{figure}


Schemat przyk³adowego TimeLine'a znajduje siê na rysunku \ref{rys_6}.Ilustruje on TimeLine-a sk³adaj¹cego siê z trzech obiektów sk³adowych: \textit{TimeLineMotion\_1}, \textit{TimeLineMotion\_2} oraz \textit{TimeLineMotion\_3}.  Pomiêdzy wszystkimi sk³adowymi obiektami zdefiniowane s¹ regu³y ³¹czenia:  \textit{TimeLineBlender\_1} oraz  \textit{TimeLineBlender\_2}.   Poza tym zdefiniowane s¹ dwa modyfikatory: \textit{TimeLineMotdifier\_1} (który modyfikuje ruch postaci jedynie w czasie wykonywania \textit{TimeLineMotion\_1}) oraz \textit{TimeLineModifier\_2} (który modyfikuje ruch podczas wykonywania ca³ego TimeLine'a).

Wykonywanie TimeLine'a z przyk³adu polega na sekwencyjnym wykonaniu kolejno trzech zdefiniowanych TimeLineMotion'ów.   

Regu³y ³¹czenia definiuje siê dla konkretnego obiektu  TimeLineMotion i zostaje on zastosowany pomiêdzy tym obiektem a jego nastêpnikiem (jeœli nastêpnik wystêpuje).

Modyfikatory równie¿ definiuje siê dla obiektów typu  TimeLineMotion. W powy¿szym przyk³adzie \textit{TimeLineMotdifier\_1} jest zdefiniowany dla \textit{TimeLineMotion\_1}, natomiast \textit{TimeLineMotdifier\_2} dla \textit{TimeLine} (takie powi¹zanie jest mo¿liwe, poniewa¿ TimeLine jest specyficzn¹ odmian¹ TimeLineMotion'a).

Ka¿dy TimeLineMotion mo¿e byæ zaznaczony jako obiekt cykliczny, co powoduje, ¿e bêdzie on wykonywany w pêtli, dopóki nie zostanie jawnie przerwany. Dopiero po jego przerwaniu zacznie byæ wykonywany jego nastêpnik. Istnieje równie¿ mo¿liwoœæ zdefiniowania liczby cyklów, po których wykonaniu ruch cykliczny zostanie przerwany automatycznie.

\subsection{Struktura obiektów TimeLineMotion}
Elementy sk³adowe obiektu TimeLineMotion przedstawione zosta³y na rysunku \ref{rys_6}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/timeLineMotion.png}
  \end{center}
  \caption{Elementy sk³adowe typu \textit{ft::TimeLineMotion}}
  \label{rys_6}
\end{figure}
W sk³ad obiektu \textit{ft::TimeLineMotion} wchodz¹ nastêpuj¹ce elementy sk³adowe:

a) \textit{Motion (animacja)} – referencja do animacji, która ma byæ wykonana przez avatara w czasie wykonywania danego TimeLineMotion'a. Referencja do animacji mo¿e byæ pusta. W tym przypadku dany TimeLineMotion sam w sobie nie powoduje ¿adnego ruchu avatar'a, natomiast mog¹ go powodowaæ jego elementy sk³adowe z \textit{tracks} i \textit{submotions}.

b) \textit{TimeLineBlender} – definicja ³¹czenia danego TimeLineMotion'a z jego nastêpnikiem. W najprostszym przypadku deiniuje on na ile przed koñcem wykonyania animacji aktualnego TimeLineMotion'a ma byæ wystartowana animacja z nastêpnego TimeLineMotion'a. Sama operacja \textit{blendowania} realizowana jest automatycznie przez engine Cal3d.

c) \textit{Submotions} – mo¿e zawieraæ sekwencje obiektów typu TimeLineMotion, które s¹ wykonywane podczas wykonywania danego TimeLineMotion'a (równoczeœnie z wykonywaniem jego animacji). Zbiór \textit{submotions} jest wykorzystywany do podzia³u danego TimeLineMotion'a na „krótsze” obiekty typu TimeLineMotion. Zbiór ten mo¿e byæ pusty – wtedy nie ma ¿adnego wp³ywu na ruch avatar'a.
 
d) \textit{Modifiers} – zawiera zbiór modyfikatorów, które s¹ wykonywane w czasie wykonywania danego TimeLineMotion'a (od pocz¹tku jego wykonywania do zakoñczenia wykonywania). Ka¿dy modyfikator mo¿e byæ podzielony dodatkowo na sekwencje „krótszych” modyfikatorów na tej samej zasadzie, zgodnie z któr¹ mo¿na podzieliæ obiekt TimeLineMotion na zbiór submotions. Zbiór \textit{modifiers} mo¿e byæ pusty – wtedy nie ma ¿adnego wp³ywu na ruch avatar'a.

\subsection{Schemat TimeLineExecutor'a}

W TimeLineExecutorze zdefiniowany jest zbior stanow, pomiêdzy którymi mo¿e on przechodziæ wykonuj¹c TimeLine'a. Na rysunku \ref{rys_7} przedstawione s¹ wszystkie 
mo¿liwe stany jak i dozwolone przejscia pomiêdzy nimi.
\\

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/timeline_executor_states.png}
  \end{center}
  \caption{Schemat przejsc pomiedzy stanami TimeLineExecutor'a}
  \label{rys_7}
\end{figure}

\textbf{Znaczenie poszczególnych stanów:}
\begin{enumerate}
\item 'NOT\_INITED' - poczatkowy stan w jakim pozostaje TimeLineExecutor do momentu inicjacji
\item 'WAIT' - w tym stanie TimeLine nie zawiera zadnych ruchow do wykoniania (jest pusty lub wszystkie skladowe ruchy zosta³y ju¿ wykonane)
\item 'FADE\_IN' - w tym stanie wykonywany jest jeden ruch (jedna animacja) przy czym jego  waga w Cal3d jest interpolowana od 0 do 1
\item 'SINGLE' - pojedynczy ruch jest wykonywany
\item 'OVERLAP' - stan ten reprezentuje "zadkladke" - czyli blending pomiêdzy dwoma kolejnymi ruchami
\item 'FADE\_OUT' - wykonywany jest jeden ruch przy czym jego  waga w Cal3d jest interpolowana od 1 do 0
\item 'TERMINATED' - ruch zosta³ nagle ztrzymany z zewn¹trz przez metode \textit{TimeLineExecutor::StopRequest()}. Aktualnie wykonywana animacja
 jest zakonczona natychmiast lub z zakonczeniem aktualnej animacji (lub aktualnego cyklu dla animacji cyklicznych)
\end{enumerate}  

\subsection{Obiekt TimeLineContext}

Podczas wykonywania TimeLine'a w TimeLineExecutorze zdefiniowany jest specjalny obiekt opisujacy aktualny stan wykonywania tzw. TimeLineContext. Parametry, które s¹ w nim zdefiniowane mog¹ byæ w ka¿dym odœwie¿eniu wykorzystane poza TimeLineExcutorem np. w modyfikatorach. Najbardziej istotne parmetry TimeLineContextu, które maj¹ funkcjê informacyjn¹, opisane s¹ poni¿ej:

\begin{enumerate}
\item prevAnim (\textit{CalAnimation*}) - animacja wykonywana poprzednio
\item currAnim (\textit{CalAnimation*}) - animacja, która jest aktualnie wykonywana
\item prevAnimTime (\textit{float}) - aktualny czas animacji poprzedniej (istotny na "zakladce", gry  poprzednia animacja ciagle trwa)
\item prevAnimDuration ( \textit{float}) - ca³kowita d³ugoœæ (czas trwania) poprzedniej animacji
\item currAnimTime (\textit{float}) - aktualny czas aktualnie wykonywanej animacji
\item currAnimDuration (\textit{float}) - ca³kowita d³ugoœæ (czas trwania) aktualnie wykonywanej animacji
\item prevOverlap (\textit{float}) - czas  \textit{blendingu} zastosowanego dla poprzedniej animacji
\item currOverlap (\textit{float}) - czas  \textit{blendingu}, który bêdzie u¿yty pomiêdzy aktualna a nastêpn¹ animacj¹
\item exec\_state (\textit{int}) - aktualny stan w jakim jest TimeLineExecutor
\item exec\_event (\textit{int})  - informacja o ostatnim zdarzeniu wygenerowanym przez TimeLineExecutor (aktualnie s¹ mo¿liwe dwie wartoœci EXEC\_EVENT\_NONE lub EXEC\_EVENT\_STATE\_CHANGED
\item anim\_changed (\textit{bool}) - ma wartoœæ  \textit{true} jeœli w aktualnym odœwie¿eniu zmieni³a siê animacja
\item anim\_new\_cycle (\textit{bool}) - ma wartoœæ  \textit{true} jeœli w aktualnym odœwie¿eniu rozpocz¹³ siê nowy cykl jeœli w³aœnie wykonywana jest animacja cykliczna
\item anim\_stopped (\textit{bool}) - ma wartoœæ  \textit{true} jeœli w aktualnym odœwie¿eniu animacja siê skoñczy³a  lub zosta³a zatrzymana
\end{enumerate}  

Oprócz parametrów informacyjnych TimeLineCOntext zawiera równie¿ parametry, które mo¿na ustawiæ z zewn¹trz:
\begin{enumerate}
\item stop\_immediate (\textit{bool}) - ustalenie czy zatrzymanie wykonywania TimeLine'a (przejscie do stanu TERMINATED) ma byæ wykonane natychmiast czy po zakoñczeniu aktualnej animacji (lub aktualnego cycklu dla animacji cyklicznych)
\item remove\_after\_execution (\textit{bool}) - ustalenie czy obiekty TimeLineMotion maj¹ byæ usuwane z TimeLine'a po wykonaniu TimeLine'a
\end{enumerate}  

\section{Modu³ ControlManager}

ControlManager jest modu³em odpowiedzialnym za zarz¹dzanie warstw¹ 'Control'. ControlManager zawiera liste avatarów na scenie, wœród których mo¿na definiowaæ aktywnego avatara. Aktywny avatar reaguje na zdarzenia pochodz¹ce od u¿ytkownika (np. z klawiatury) poprzez wykonywanie odpowiednich akcji. Gdy ¿aden avatar nie jest aktywny w danym momencie to zale¿nie od zdarzenia akcje wykonywane s¹ przez wszystkie avatary z listy ControlManager'a lub nie wykonywane s¹ wcale.
\\

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/control_manager.png}
  \end{center}
  \caption{powi¹zania pomiêdzy avatarami, stanami i ControlManager'em}
  \label{rys_8}
\end{figure}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/control_states.png}
  \end{center}
  \caption{powi¹zania pomiêdzy avatarami, stanami i ControlManager'em}
  \label{rys_9}
\end{figure}


Wykonywanie akcji przez avatara polega na przechodzeniu pomiedzy poszczególnymi stanami (tzw. \textit{ControlState's}).  Ka¿dy avatar posiada w³asny i niezale¿ny zbiór stanów, pomiêdzy którymi mo¿e "przechodziæ". Ka¿dy stan ControlState posiada 3 metode, które wo³ane s¹ w momencie inicjacji stanu (\textit{Init()}), wejœcia do tego stanu (\textit{Entry()}) oraz wyjœcia ze stanu (\textit{Exit()}).
\\

Na rysunku \ref{rys_8} przedstawione s¹ powi¹zania pomiêdzy avatarami, stanami i ControlManager'em.
\\

Na rysunku \ref{rys_9} pokazany jest przyk³adowy schemat przejœæ pomiêdzy stanami dla jednego avatara.
\\



\section{Organizacja obiektow graficznych}
\subsection{Motywacja}
Wizualizacja nie jest g³ównym celem ca³ego systemu, i przez to nie jest wykonana w sposób kompleksowy i ca³kowicie uniwersalny. Jednak¿e mechanizmy do wizualizacji elementów systemu bazuj¹ na pewnych za³o¿eniach pozwalaj¹cych zaimplementowaæ je  ³atwo w innych systemach wizualizacji (np. OSG) lub przy pomocy dowolnego API (np. DirectX). Za³o¿ono niezale¿noœæ od standardów korporacyjnych (MS) i wybrano OpenGL API. Aby zminimalizowaæ wp³yw strumienia graficznego na ca³kowit¹ wydajnoœæ systemu,  przerzucono czêœæ operacji graficznych na procesor akceleratora graficznego przez u¿ycie sprzêtowego wspomagania (vertex shader).

\subsection{Wizualizacja}
Wizualizacja obiektów stanowi niezale¿ny mechanizm generatora i poprzez œciœle okreœlone regu³y i interfejsy dzia³a w sposób niezale¿ny od reszty implementacji. Generaln¹ ideê relacji pomiêdzy podstawowymi obiektami wizualizacji w systemie przedstawiono na rysunku \ref{rys_10}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/collab.png}
  \end{center}
  \caption{Wzajemne relacje wspó³pracy obiektów wizualizacji}
  \label{rys_10}
\end{figure}


\textbf{Zasady renderowania obiektów graficznych w systemie:}
\begin{enumerate}
\item 1.Ka¿dy obiekt który ma byæ w³¹czony do potoku renderuj¹cego musi implementowaæ interfejs (pokrywa metodê \textit{Render}) obiektu \textit{ft::SceneObject}.
\item 2. Ka¿dy obiekt, który ma byæ w³¹czony do potoku renderuj¹cego jest musi byæ zarejestrowany przez obiekt \textit{ft::VisualizationManager} przy pomocy metody \textit{ft::VisualizationManager::AddObject} 
\item 3.Obiekt \textit{ft::VisualizationManager} wywo³uje cyklicznie metodê \textit{ft::VisualizationManager::OnRender}, zsynchronizowan¹ z mechanizmem GLUT, i przetwarza wszystkie zarejestrowane obiekty wywo³uj¹c metodê Render ka¿dego z nich.
\end{enumerate}  
\subsubsection{ft::SceneObject}
Podstawowy obiekt graficzny. Realizuje bazowy interfejs obiektu sceny (kolor, po³o¿enie, nazwa obiektu, aktywnoœæ) i udostêpnia interfejs renderowania obiektu - metoda \textit{Render} oraz  \textit{RenderShadow}.

\subsubsection{ft::MenuItem}
Podstawowy element menu graficznego, korzysta z bazowych w³asnoœci typu \textit{ft::SceneObject}
Jego kszta³t i w³aœciwoœci mog¹ byæ dostosowane do specyficznych wymagañ poprzez w³asn¹ implementacjê metody \textit{Render}. MenuItem implementuje najprostsz¹ postaæ wzorca composite dziêki czemu mo¿e funkcjonowaæ jako struktura drzewiasta co pokazano na rysunku \ref{rys_11}.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/menuItem.png}
  \end{center}
  \caption{Przyk³adowa implementacja wielopoziomowego menu przy pomocy obiektu \textit{ft::MenuItem}}
  \label{rys_11}
\end{figure}

\subsubsection{ft::Line}
Pozwala realizowaæ ró¿ne warianty linii lub strza³kê w trzech wymiarach. Obiekt mo¿na definiowaæ zadaj¹c mu pocz¹tek, koniec, d³ugoœæ, orientacjê i kolor. G³ówn¹ motywacj¹ by³o zastosowanie go w charakterze markera. W obszarze renderowania implementuje w³asn¹ metodê \textit{Render}.

\subsubsection{ft::TraceLine}
Pozwala realizowaæ liniê wielosegmentow¹ po³¹czon¹ markerami w trzech wymiarach poprzez zadawanie punktu w przestrzeni metod¹  \textit{ft::TraceLine::AddPoint}. Obiekt mo¿e wyœwietlaæ i ukrywaæ markery, ustawiaæ kolor ka¿dego segmentu. Doskonale nadaje siê do wizualizacji miejsc, w których trzeba œledziæ po³o¿enie przesuwaj¹cego siê obiektu. W obszarze renderowania implementuje w³asn¹ metodê \textit{Render}.

\subsubsection{ft:Avatar}
W kontekœcie wizualizacji jest to obiekt graficzny z najbardziej rozbudowan¹ struktur¹ renderowania. Obiekt \textit{ft::Avatar} posiada trzy mo¿liwoœci renderowania: renderowanie szkieletu, renderowanie ograniczeñ ka¿dej koœci lub renderowanie siatki modelu (mesha). Dodatkowo ze wzglêdu na z³o¿onoœæ siatki modelu wprowadzono mo¿liwoœæ sprzêtowego renderowania siatki modelu przy u¿yciu vertex shadera. Po wyborze metody renderowania Avatara dochodzi jeszcze renderowanie cienia obiektu, które jest realizowane przed renderowaniem ca³ego obiektu przez metodê \textit{RenderShadow} jako element globalnej metody renderowania cienia (np. przez \textit{ft::VisualizationManager}). Przep³yw potoku renderuj¹cego zwi¹zanego z renderowaniem avatara przedstawiono na rysunku \ref{rys_12}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/avatarPipeline.png}
  \end{center}
  \caption{Potok renderowania dla typu \textit{ft::Avatar}. Linie przerywane oznaczaj¹ œcie¿ki alternatywne potoku renderuj¹cego.}
  \label{rys_12}
\end{figure}


\subsubsection{ft::TextureManager}
£aduje, przechowuje i udostêpnia  innym obiektom tektury wczytywane z plików. Pozwala przetwarzaæ pliki graficzne w formatach PCX, BMP i TGA (wy³¹cznie 24 bitowe). Manager tekstur jest ³atwo rozszerzalny i pozwala skorzystaæ z plików graficznych w innych formatach przez prost¹ modyfikacjê jednej metody  \textit{ft::TextureManager::LoadTexture}. Poprzez globaln¹ mapê tekstur eliminuje potrzebê wielokrotnego wczytywania tych samych plików teksturami. Aby korzystaæ z w³aœciwoœci tego obiektu musi byæ aktywny kontekst OpenGL do przetwarzania tekstur (glEnable(GL\_TEXTURE)).  

\subsubsection{ft::MenuManager}
Zarz¹dza kolekcj¹ obiektów typu \textit{ft::MenuItem}. Tworzy menu graficzne na podstawie definicji w pliku konfiguracyjnym. Obs³uguje komunikaty z zewn¹trz od obiektu \textit{ft::UpdateManager} i z lokalnych obiektów \textit{ft::MenuItem} oraz generuje komunikat do systemu o wciœniêciu konkretnego przycisku w menu (MSG\_MENU\_ITEM\_SELECTED) dla wszystkich zarejestrowanych obiektów nas³uchuj¹cych. Ze wzglêdu na interakcjê przy pomocy klawiatury i myszy, korzysta z \textit{ft::InputManagera} przy obs³udze komunikatów z tych urz¹dzeñ.

\subsubsection{ft::VisualizationManager}
Centralny element zarz¹dzania elementami graficznymi sceny. Realizuje komunikacjê z pozosta³ymi niegraficznymi elementami systemu. Obiekt \textit{ft::VisualizationManager} jest odpowiedzialny za renderowanie wszystkich obiektów graficznych typu \textit{ft:SceneObject}, przy pomocy metody \textit{Render3DObjects}. Wszystkie obiekty, które maj¹ byæ automatycznie renderowane musz¹ byæ uprzednio zarejestrowane do renderowania metod¹ \textit{ft::VisualizationManager::AddObject}. 	

\subsubsection{ft::OGLContext}
Tworzy zawartoœæ renderowania (prymitywy graficzne) przy pomocy API OpenGL. Buduje wizualne, trwa³e elementy sceny (pod³oga, logo), korzysta z tekstur obiektu \textit{ft::TextureManager}.

\subsubsection{ft::Camera}
Tworzy cztery rodzaje kamer, oraz aktualizuje widok dla aktywnej kamery. Jest obiektem zarz¹dzanym ca³kowicie przez \textit{ft::CameraManager}. 

\subsection{ft::CameraManager}
Zarz¹dza realcjami pomiêdzy stworzonymi kamerami i obiektami sceny. Tworzy dla dowolnego obiektu sceny kamerê, której identyfikator odpowiada ID przypisanego obiektu sceny. Przetwarza komunikaty z klawiatury i myszy dotycz¹ce aktywnej kamery. Aktualizuje parametry bie¿¹cej kamery oraz widoku dla kontekstu rederowania \textit{ft::VisualizationManager}.  
\textit{ft::CameraManager} zarz¹dza kolekcj¹ kamer. Do podstawowych operacji nale¿y:
\begin{enumerate}
\item Prze³¹czanie bie¿¹cego widoku miêdzy zdefiniowanymi kamerami - klawisze \textbf{[} oraz \textbf{]}
\item Powiêkszenie obserwowanego fragmentu - klawisz \textbf{|}
\item Zmiana rodzaju bie¿¹cej kamery - klawisz \textbf{\textbackslash}
\end{enumerate}

Do prze³¹czania siê pomiêdzy zdefiniowanymi kamerami w systemie s³u¿¹ klawisze \textbf{[} oraz \textbf{]}. Opcja powiêkszenia (zoom) u³atwia obserwacjê szczegó³ów widoku. Zoom w³¹cza siê oraz wy³¹cza za pomoc¹ jednokrotnego wciœciêcia klawisza \textbf{|}. Zmiana rodzaju bie¿¹cej kamery nastêpuje po wciœniêciu klawisza. W systemie zdefiniowano 4 rodzaje kamer:
\begin{enumerate}
\item \textit{StaticCamera} - sztywna kamera bez mo¿liwoœci poruszania, pozwala tylko na statyczny widok z okreœlonego miejsca
\item \textit{ThirdPersonCamera} - kamera z pozycji trzeciej osoby. Pod¹¿a za celem i nie mo¿na ni¹ sterowaæ
\item \textit{OrbitCamera} - kamera obraca siê wokó³ punktu celu.
\item \textit{FlyCamera} - kamera umo¿liwia przesuwanie widoku manualnie:
\begin{enumerate}
\item Do przodu - klawisz \textbf{w}.
\item Do ty³u - klawisz \textbf{s}.
\item W lewo - klawisz \textbf{a}.
\item W prawo - klawisz \textbf{d}.
\item W górê - klawisz \textbf{r}.
\item W dó³ - klawisz \textbf{f}.
\item Obrót o 360 stopni (odchylenie) - wciœniêty lewy klawisz myszy i przesuwanie jej w poziomie.
\item Obrót w zakresie +-90 stopni w górê i w dó³ od p³aszczyzny bie¿¹cego widoku (nachylenie) - wciœniêty lewy klawisz myszy i przesuwanie jej w pionie.
\end{enumerate}
\end{enumerate}
W wypadku, gdy kamera nie jest dowi¹zana do dynamicznego obiektu sceny, tryb \textit{ThirdPersonCamera} jest dla niej niedostêpny. Przyk³adem tego typu jest g³ówna kamera \textit{MainCamera}. Obiekt, do którego przypisana jest bie¿¹ca kamera jest oznaczony migaj¹cym kwadratem w odpowiednim kolorze - w zale¿noœci od rodzaju aktywnej kamery. Dla trybu \textit{StaticCamera} jest to kolor zielony, dla \textit{ThirdPersonCamera} kolor pomarañczowy,  dla \textit{OrbitCamera} kolor czerwony oraz kolor jasny niebieski dla trybu \textit{FlyCamera}.

\subsection{CameraConfiguration}
Pozwala zmieniaæ wartoœci parametrów zdefiniowanych w systemie kamer i umo¿liwia dostêp do takich konfiguracji przez zdefiniowanie klawisza dostêpu. Definicja odbywa siê w pliku konfiguracyjnym aplikacji i zosta³a opisana rozdziale dotycz¹cym konfiguraji.

\subsection{Renderowanie Sprzêtowe}
Ka¿dy obiekt typu \textit{ft::SceneObject} mo¿e implementowaæ w³asne sprzêtowe renderowanie przy u¿yciu jêzyka assemblera ARB: \textit{ARB vertex program} oraz/lub \textit{ARB fragment program}. Aby zrealizowaæ sprzêtowe renderowanie wybranego obiektu nale¿y:
\begin{enumerate}
\item Utworzyæ pliki z kodem vertex shaderów i pixel shaderów dla fragmentów lub ca³ego obiektu graficznego w katalogu \textbf{shaders}. Shadery dla pixel shaderów (fragmentów programy) powinny mieæ rozszerzenie \textit{.frag} natomiast dla vertex shaderów (vertex programy) \textit{.vert}.
\item Utworzyæ w kodzie obiektu graficznego metody do inicjalizacji i wczytywania shaderów oraz rezerwacji pamiêci, analogicznie do metod \textit{Avatar::InitHardwareAcceleration} i \textit{Avatar::loadBufferObject}.
\item Utworzyæ w kodzie obiektu graficznego metodê renderuj¹c¹ obiekt przy pomocy sprzêtu analogiczn¹ do \textit{Avatar::HardwareRenderModelMesh}
\end{enumerate}


\flushright

\end{document}

