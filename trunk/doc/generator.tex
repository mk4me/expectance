%Autor: Marek Kulbacki, Artur Bak

\documentclass[12pt,a4paper]{article}
%-- header poczatek ------------------------------------------------
\usepackage[textwidth=16cm, textheight=24cm, centering]{geometry}
\usepackage[colorlinks=true, linkcolor=blue, hyperindex, bookmarksopen]{hyperref} 
\usepackage{color} 
\usepackage{graphicx}	

\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
\frenchspacing 
\sloppy
%-- header koniec --------------------------------------------------

%-- dokument poczatek ----------------------------------------------
\begin{document}

\begin{titlepage}
 
\begin{center}
\vfill
\vspace*{5 cm}
\includegraphics[width=0.5\textwidth]{./img/ft_logo.png}\\[1cm]
\vspace*{2 cm}
 
\textsc{\huge \textbf{Generator}}\\[1.5cm]
 
\textsc{\Large dokumentacja analityczna}\\[0.5cm]
 
 
 \vfill
\end{center}
% Author and supervisor
\begin{flushleft} \small
Wersja: 0.6 \\
Data modyfikacji: \today \\
Autorzy: A.\textsc{B¹k} and M.\textsc{Kulbacki}\\
\end{flushleft}
% Bottom of the page

\end{titlepage}



\tableofcontents

\vspace*{2ex}
\hrule

\section{Model aplikacji Generator'a}
Aplikacja Generator'a bazuje na dwóch g³ównych bibliotekach: 
\\
- GLUT – u¿ywana do zarz¹dzania aplikacj¹ okienkow¹ oraz podstawowych operacji graficznych
\\
- Cal3d – u¿ywana do reprezentacji modeli avatarów oraz zarz¹dzanie animacjami dla nich
\\

Do szybkiego ustawiania parametrów aplikacji oraz jej sk³adowych modu³ów s³u¿y plik \textit{/data/application.cfg}.
Modele avatarów oraz animacje dla nich opisane s¹ w standardowym formacie modeli Cal3d (pliki xsf/xaf/xmf/xrf  lub csf/caf/cmf/crf opisane skryptami \textit{*.cfg)}.
\\

Ogólna ilustracja struktury aplikacji Generator'a zosta³a przedstawiona na rysunku \ref{rys_0}.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/generator_app.png}
  \end{center}
  \caption{Struktura aplikacji Generator'a}
  \label{rys_0}
\end{figure}

\section{Avatar'y}
Podstawow¹ klas¹ reprezentuj¹c¹ animowan¹ postaæ jest Avatar. Mo¿na go dodawaæ do sceny oraz wykonywaæ na nim animacje. Obiekty typu Avatar bazuj¹ na modelach postaci z API Cal3d i mo¿na je traktowaæ jako odpowiedniki takich modeli z rozszerzona funkcjonalnoœci¹ na potrzeby Generatora.
\subsection{Powi¹zania Avatar'ów z modelami w API Cal3D}
Podstawowym bytem reprezentuj¹cym animowan¹ postaæ w API Cal3Dd jest obiekt CalModel. Obiekt CalModel mo¿e byæ utworzony na podstawie odpowiedniego typu. Definicj¹ takiego typu w Cal3d jest  obiekt CalCoreModel. 

Ró¿nica pomiêdzy CalCoreModelem i CalModelem jest taka, ze CalCoreModel zawiera definicje mesh'y, animacji, materia³ów oraz szkieletu postaci. CalModel jest natomiast specyficzna instancj¹ CalCoreModelu i mo¿na go ustawiaæ na scenie oraz wykonywaæ na nim animacje. Dla ka¿dego takiego typu mo¿e istnieæ dowolna iloœæ obiektów klasy CalModel.

Dla ka¿dego utworzonego obiektu klasy Avatar utworzony zostaje osobny obiekt  klasy CalModel w enginie Cal3d.   Ponadto obiekt Avatar zawiera referencjê do odpowiedniego obiektu CalCoreModel, na którego podstawie zosta³ utworzony jego CalModel. Dziêki temu z poziomu Avatar'a mo¿na odwo³ywaæ siê do definicji postaci.

Na rysunku \ref{rys_1} znajduje siê ilustracja przyk³adowej struktury modeli.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/modelCal3D.png}
  \end{center}
  \caption{Ilustracja przyk³adowej struktury modeli opartych na Cal3D}
  \label{rys_1}
\end{figure}

\subsection{Tworzenie avatarów}
Aby utworzyæ obiekt Avatar nale¿y wczeœniej utworzyæ dla niego odpowiedni obiekt CalModel w Cal3d oraz u¿yæ do tego odpowiedniego typu, czyli obiektu CalCoreModel.  Obiekt CalCoreModel tworzony jest na podstawie pliku konfiguracyjnego w formacie Cal3d (.cfg).  Nalezy przy tym pamiêtaæ, ¿e ten dany typ reprezentowany przez obiekt CalCoreModel wystarczy utworzyæ (wczytaæ z pliku .cfg) tylko jeden raz.  Nastêpnie mo¿na go u¿ywaæ do tworzenia dowolnej iloœci obiektów klasy CalModel.

Po utworzeniu danego obiektu CalCoreModel na podstawie pliku .cfg nale¿y dla niego zainicjowaæ materia³y. Z kolei po utworzeniu obiektu CalModel nale¿y odpowiednio zainicjowaæ meshe na podstawie CalCoreModelu. Powy¿sze operacje nale¿y wykonaæ w odpowiedniej kolejnoœci.

Aby uproœciæ tworzenie obiektu Avatar oraz jego relacji z modelami Cal3d zosta³a utworzona klasa   AvatarFactory.  Wystarczy wywo³aæ metodê  AvatarFactory.CreateAvatar() oraz zadaæ nazwê dla CalCoreModel'u (która odpowiada nazwie pliku .cfg) oraz dowoln¹ nazwê dla Avatar.  Ca³a operacja tworzenia Avatara odbywa siê wewn¹trz tej metody.

Dodatkowo  klasa AvatarFactory zapewnia zarz¹dzanie CalCoreModel'ami, tak aby ka¿dy osobny typ nie zosta³ utworzony wiêcej ni¿ jeden raz, nawet gdy odwo³amy siê do niego wiele razy

\subsection{Przechowywanie ruchów (animacji) dla Avatarów}
Animacje dla avatarów s¹ reprezentowane przez obiekty klasy \textit{Motion}. S¹ one kolekcjonowane w klasie \textit{MovableAvatar}, która jest pochodn¹ klasy \textit{Avatar}. Jeden obiekt klasy \textit{Motion} powi¹zany jest z dok³adnie jednym obiektem klasy \textit{CalCoreAnimation} w enginie Cal3d.  Animacja CalCoreAnimation jest w Cal3d sk³adow¹ CalCoreModel'u i jest wykonywana przez odpowiednie CalModel'e. 

Ilustracja struktury powi¹zañ dotycz¹cych animacji znajduje sie na rysunku \ref{rys_2}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{./img/coreModelAvatar.png}
  \end{center}
  \caption{Powi¹zania struktur dotycz¹cych animacji w Cal3D i Generatorze}
  \label{rys_2}
\end{figure}


\section{Modu³ UpdateManager}
Modu³ UpdateManager jest jednym z bazowych modu³ów Generatora.  Do jego g³ównych zadañ nale¿y odœwie¿anie obiektów w ka¿dej klatce symulacji (frame) oraz rozsy³anie wiadomoœci do zainteresowanych obiektów.

G³ówn¹ klas¹ modu³u jest \textit{UpdateManager}, która posiada tylko jedn¹ instancjê (Singleton).  

Aby obiekty mog³y byæ odœwie¿anie przez \textit{UpdateManagera} lub odbieraæ wiadomoœci musz¹ byæ pochodnymi klasy \textit{UpdateObject} oraz byæ zarejestrowanie w UpdateManager'ze.

\subsection{Odœwie¿anie obiektów}
Aby dany obiekt  móg³ reagowaæ na odœwie¿enie w ka¿dej klatce animacji powinien pokryæ metodê \textit{OnUpdate (float elapsedTime)} z klasy bazowej UpdateObject.  Parametr \textit{elapsedTime} okreœla ile czasu minê³o od poprzedniego odœwie¿enia. UpdateManager bêdzie wywo³ywa³ metodê \textit{OnUpdate} na wszystkich zarejestrowanych obiektach zgodnie z parametrami okreœlonymi dla aktualnej symulacji (klasa \textit{ft::Simulation}). Klasa \textit{ft::Simulation} odczytuje czas przy pomocy metody \textit{getTick()}. W zale¿noœci od potrzeby mo¿na pobieraæ czas z dok³adnoœci¹ do mili albo mikrosekund.
\subsection{Rozsy³anie wiadomoœci}
UpdateManager rozsy³a wiadomoœci do zarejestrowanych obiektów za pomoc¹ obiektów klasy \textit{ft::Message}.  Wywo³uje w tym celu na obiektach funkcje \textit{OnMessage(Message* msg)}, która jest zdefiniowana w klasie \textit{UpdateObject}. Aby obiekt móg³ zareagowaæ na wiadomoœæ powinien on pokryæ metodê \textit{OnMessage} i zaimplementowaæ w niej rozpoznanie typu wiadomoœci oraz odpowiednie akcje.

Ka¿dy obiekt w systemie mo¿e wys³aæ wiadomoœæ przez UpdateManager'a u¿ywaj¹c metody \textit{SendMessage(Message* msg, bool deleteAfterSent)}.  Jako parametr \textit{msg} nale¿y podstawiæ w³aœciwy obiekt typu \textit{Message}, natomiast \textit{deleteAfterSend} okreœla czy UpdateManager ma zwolniæ pamiêæ dla obiektu \textit{msg} po rozes³aniu go do zarejestrowanych obiektów.

Ilustracja przep³ywu sterowania podczas rozsy³ania wiadomoœci znajduje siê na rysunku \ref{rys_3}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/controlManager.png}
  \end{center}
  \caption{Przesy³anie wiadomoœci miêdzy obiektami implementuj¹cymi interfejs wiadomoœci UpdateManagera}
  \label{rys_3}
\end{figure}


\section{Sterowanie ruchem – TimeLine'y}
Idea sterowania ruchem bazuje na pojêciu TimeLine'ow. TimeLine mo¿na traktowaæ jako œcie¿kê animacji, któr¹ avatar ma za zadanie wykonaæ. TimeLine reprezentowany jest przez obiekty typu \textit{ft::TimeLine}.

Zadany do wykonania TimeLine jest wype³niony obiektami typu \textit{ft::TimeLineMotion}. Obiekty typu TimeLineMotion maj¹ wskazania na animacje, które s¹ wykonywane przez avatar'a w trakcie wykonywania danego TimeLineMotion'a na œcie¿ce animacji.

Pomiêdzy kolejnymi obiektami TimeLineMotion mog¹ byæ zdefiniowane regu³y ³¹czenia. Regu³y ³¹czenia s¹ reprezentowane przez obiekty typu \textit{ft::TimeLineBlender}.

Podczas wykonywania TimeLineMotion'a, ruch avatara mo¿e byæ modyfikowany w dowolny sposób przez jeden lub kilka modyfikatorów ruchu. Ka¿dy modyfikator jest opisany w obiekcie typu \textit{ft::TimeLineModifier}.


Rozpoczêcie wykonywania TimeLine'a rozpoczyna siê w momencie wykonania na nim metody Start(). Wykonanie TimeLine'a polega na wykonaniu po kolei wszystkich jego sk³adowych TimeLineMotion'ow.   

Obiekty typu TimeLine s¹ pochodnymi klasy TimeLineMotion, co oznacza ze ca³e TimeLine'y mog¹ byæ u¿yte jako sk³adowe innych TimeLine'ów, co zapewnia du¿¹ elastycznoœæ w definiowaniu i sterowaniu ruchem.


\subsection{Struktura TimeLine'a oraz relacje pomiêdzy jego sk³adowymi elementami}
 
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/timeLine.png}
  \end{center}
  \caption{Przep³yw informacji w obrêbie zdefiniowanego timeline-a}
  \label{rys_4}
\end{figure}


Schemat przyk³adowego TimeLine'a znajduje siê na rysunku \ref{rys_4}.Ilustruje on TimeLine-a sk³adaj¹cego siê z trzech obiektów sk³adowych: \textit{TimeLineMotion\_1}, \textit{TimeLineMotion\_2} oraz \textit{TimeLineMotion\_3}.  Pomiêdzy wszystkimi sk³adowymi obiektami zdefiniowane s¹ regu³y ³¹czenia:  \textit{TimeLineBlender\_1} oraz  \textit{TimeLineBlender\_2}.   Poza tym zdefiniowane s¹ dwa modyfikatory: \textit{TimeLineMotdifier\_1} (który modyfikuje ruch postaci jedynie w czasie wykonywania \textit{TimeLineMotion\_1}) oraz \textit{TimeLineModifier\_2} (który modyfikuje ruch podczas wykonywania ca³ego TimeLine'a).

Wykonywanie TimeLine'a z przyk³adu polega na sekwencyjnym wykonaniu kolejno trzech zdefiniowanych TimeLineMotion'ów.   

Regu³y ³¹czenia definiuje siê dla konkretnego obiektu  TimeLineMotion i zostaje on zastosowany pomiêdzy tym obiektem a jego nastêpnikiem (jeœli nastêpnik wystêpuje).

Modyfikatory równie¿ definiuje siê dla obiektów typu  TimeLineMotion. W powy¿szym przyk³adzie \textit{TimeLineMotdifier\_1} jest zdefiniowany dla \textit{TimeLineMotion\_1}, natomiast \textit{TimeLineMotdifier\_2} dla \textit{TimeLine} (takie powi¹zanie jest mo¿liwe, poniewa¿ TimeLine jest specyficzn¹ odmian¹ TimeLineMotion'a).

Ka¿dy TimeLineMotion mo¿e byæ zaznaczony jako obiekt cykliczny, co powoduje, ¿e bêdzie on wykonywany w pêtli, dopóki nie zostanie jawnie przerwany. Dopiero po jego przerwaniu zacznie byæ wykonywany jego nastêpnik. Istnieje równie¿ mo¿liwoœæ zdefiniowania liczby cyklów, po których wykonaniu ruch cykliczny zostanie przerwany automatycznie.
\subsection{Struktura obiektów TimeLineMotion}
Elementy sk³adowe obiektu TimeLineMotion przedstawione zosta³y na rysunku \ref{rys_5}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/timeLineMotion.png}
  \end{center}
  \caption{Elementy sk³adowe typu \textit{ft::TimeLineMotion}}
  \label{rys_5}
\end{figure}
W sk³ad obiektu \textit{ft::TimeLineMotion} wchodz¹ nastêpuj¹ce elementy sk³adowe:

a) \textit{Motion (animacja)} – referencja do animacji, która ma byæ wykonana przez avatara w czasie wykonywania danego TimeLineMotion'a. Referencja do animacji mo¿e byæ pusta. W tym przypadku dany TimeLineMotion sam w sobie nie powoduje ¿adnego ruchu avatar'a, natomiast mog¹ go powodowaæ jego elementy sk³adowe z \textit{tracks} i \textit{submotions}.

b) \textit{TimeLineBlender} – definicja ³¹czenia danego TimeLineMotion'a z jego nastêpnikiem. W najprostszym przypadku deiniuje on na ile przed koñcem wykonyania animacji aktualnego TimeLineMotion'a ma byæ wystartowana animacja z nastêpnego TimeLineMotion'a. Sama operacja \textit{blendowania} realizowana jest automatycznie przez engine Cal3d.

c) \textit{Tracks} – mo¿e zawieraæ dodatkowe œcie¿ki ruchów, które bêd¹ wykonywane równolegle do TimeLineMotion'a. Ka¿da œcie¿ka ma postaæ obiektu TimeLineMotion.  Œcie¿ki mog¹ byæ wykorzystane do realizacji ruchów dla poszczególnych partii cia³a avatar'a. Zbiór œcie¿ek mo¿e byæ pusty – wtedy nie ma ¿adnego wp³ywu na ruch avatar'a.

d) \textit{Submotions} – mo¿e zawieraæ sekwencje obiektów typu TimeLineMotion, które s¹ wykonywane podczas wykonywania danego TimeLineMotion'a (równoczeœnie z wykonywaniem jego animacji). Zbiór \textit{submotions} jest wykorzystywany do podzia³u danego TimeLineMotion'a na „krótsze” obiekty typu TimeLineMotion. Zbiór ten mo¿e byæ pusty – wtedy nie ma ¿adnego wp³ywu na ruch avatar'a.
 
e) \textit{Modifiers} – zawiera zbiór modyfikatorów, które s¹ wykonywane w czasie wykonywania danego TimeLineMotion'a (od pocz¹tku jego wykonywania do zakoñczenia wykonywania). Ka¿dy modyfikator mo¿e byæ podzielony dodatkowo na sekwencje „krótszych” modyfikatorów na tej samej zasadzie, zgodnie z któr¹ mo¿na podzieliæ obiekt TimeLineMotion na zbiór submotions. Zbiór \textit{modifiers} mo¿e byæ pusty – wtedy nie ma ¿adnego wp³ywu na ruch avatar'a.


\section{Organizacja obiektow graficznych}
\subsection{Motywacja}
Wizualizacja nie jest g³ównym celem ca³ego systemu, i przez to nie jest wykonana w sposób kompleksowy i ca³kowicie uniwersalny. Jednak¿e mechanizmy do wizualizacji elementów systemu bazuj¹ na pewnych za³o¿eniach pozwalaj¹cych zaimplementowaæ je  ³atwo w innych systemach wizualizacji (np. OSG) lub przy pomocy dowolnego API (np. DirectX). Za³o¿ono niezale¿noœæ od standardów korporacyjnych (MS) i wybrano OpenGL API. Aby zminimalizowaæ wp³yw strumienia graficznego na ca³kowit¹ wydajnoœæ systemu,  przerzucono czêœæ operacji graficznych na procesor akceleratora graficznego przez u¿ycie sprzêtowego wspomagania (vertex shader).

\subsection{Wizualizacja}
Wizualizacja obiektów stanowi niezale¿ny mechanizm generatora i poprzez œciœle okreœlone regu³y i interfejsy dzia³a w sposób niezale¿ny od reszty implementacji. Generaln¹ ideê relacji pomiêdzy podstawowymi obiektami wizualizacji w systemie przedstawiono na rysunku \ref{rys_6}.
\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/collab.png}
  \end{center}
  \caption{Wzajemne relacje wspó³pracy obiektów wizualizacji}
  \label{rys_6}
\end{figure}


\textbf{Zasady renderowania obiektów graficznych w systemie:}
\begin{enumerate}
\item 1.Ka¿dy obiekt który ma byæ w³¹czony do potoku renderuj¹cego musi implementowaæ interfejs (pokrywa metodê \textit{Render}) obiektu \textit{ft::SceneObject}.
\item 2. Ka¿dy obiekt, który ma byæ w³¹czony do potoku renderuj¹cego jest musi byæ zarejestrowany przez obiekt \textit{ft::VisualizationManager} przy pomocy metody \textit{ft::VisualizationManager::AddObject} 
\item 3.Obiekt \textit{ft::VisualizationManager} wywo³uje cyklicznie metodê \textit{ft::VisualizationManager::OnRender}, zsynchronizowan¹ z mechanizmem GLUT, i przetwarza wszystkie zarejestrowane obiekty wywo³uj¹c metodê Render ka¿dego z nich.
\end{enumerate}  
\subsubsection{ft::SceneObject}
Podstawowy obiekt graficzny. Realizuje bazowy interfejs obiektu sceny (kolor, po³o¿enie, nazwa obiektu, aktywnoœæ) i udostêpnia interfejs renderowania obiektu - metoda \textit{Render} oraz  \textit{RenderShadow}.

\subsubsection{ft::MenuItem}
Podstawowy element menu graficznego, korzysta z bazowych w³asnoœci typu \textit{ft::SceneObject}
Jego kszta³t i w³aœciwoœci mog¹ byæ dostosowane do specyficznych wymagañ poprzez w³asn¹ implementacjê metody \textit{Render}. MenuItem implementuje najprostsz¹ postaæ wzorca composite dziêki czemu mo¿e funkcjonowaæ jako struktura drzewiasta co pokazano na rysunku \ref{rys_7}.

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/menuItem.png}
  \end{center}
  \caption{Przyk³adowa implementacja wielopoziomowego menu przy pomocy obiektu \textit{ft::MenuItem}}
  \label{rys_7}
\end{figure}

\subsubsection{ft::Line}
Pozwala realizowaæ ró¿ne warianty linii lub strza³kê w trzech wymiarach. Obiekt mo¿na definiowaæ zadaj¹c mu pocz¹tek, koniec, d³ugoœæ, orientacjê i kolor. G³ówn¹ motywacj¹ by³o zastosowanie go w charakterze markera. W obszarze renderowania implementuje w³asn¹ metodê \textit{Render}.

\subsubsection{ft::TraceLine}
Pozwala realizowaæ liniê wielosegmentow¹ po³¹czon¹ markerami w trzech wymiarach poprzez zadawanie punktu w przestrzeni metod¹  \textit{ft::TraceLine::AddPoint}. Obiekt mo¿e wyœwietlaæ i ukrywaæ markery, ustawiaæ kolor ka¿dego segmentu. Doskonale nadaje siê do wizualizacji miejsc, w których trzeba œledziæ po³o¿enie przesuwaj¹cego siê obiektu. W obszarze renderowania implementuje w³asn¹ metodê \textit{Render}.

\subsubsection{ft:Avatar}
W kontekœcie wizualizacji jest to obiekt graficzny z najbardziej rozbudowan¹ struktur¹ renderowania. Obiekt \textit{ft::Avatar} posiada trzy mo¿liwoœci renderowania: renderowanie szkieletu, renderowanie ograniczeñ ka¿dej koœci lub renderowanie siatki modelu (mesha). Dodatkowo ze wzglêdu na z³o¿onoœæ siatki modelu wprowadzono mo¿liwoœæ sprzêtowego renderowania siatki modelu przy u¿yciu vertex shadera. Po wyborze metody renderowania Avatara dochodzi jeszcze renderowanie cienia obiektu, które jest realizowane przed renderowaniem ca³ego obiektu przez metodê \textit{RenderShadow} jako element globalnej metody renderowania cienia (np. przez \textit{ft::VisualizationManager}). Przep³yw potoku renderuj¹cego zwi¹zanego z renderowaniem avatara przedstawiono na rysunku \ref{rys_8}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=1\textwidth]{./img/avatarPipeline.png}
  \end{center}
  \caption{Potok renderowania dla typu \textit{ft::Avatar}. Linie przerywane oznaczaj¹ œcie¿ki alternatywne potoku renderuj¹cego.}
  \label{rys_8}
\end{figure}


\subsubsection{ft::TextureManager}
£aduje, przechowuje i udostêpnia  innym obiektom tektury wczytywane z plików. Pozwala przetwarzaæ pliki graficzne w formatach PCX, BMP i TGA (wy³¹cznie 24 bitowe). Manager tekstur jest ³atwo rozszerzalny i pozwala skorzystaæ z plików graficznych w innych formatach przez prost¹ modyfikacjê jednej metody  \textit{ft::TextureManager::LoadTexture}. Poprzez globaln¹ mapê tekstur eliminuje potrzebê wielokrotnego wczytywania tych samych plików teksturami. Aby korzystaæ z w³aœciwoœci tego obiektu musi byæ aktywny kontekst OpenGL do przetwarzania tekstur (glEnable(GL\_TEXTURE)).  

\subsubsection{ft::MenuManager}
Zarz¹dza kolekcj¹ obiektów typu \textit{ft::MenuItem}. Tworzy menu graficzne na podstawie definicji w pliku konfiguracyjnym. Obs³uguje komunikaty z zewn¹trz od obiektu \textit{ft::UpdateManager} i z lokalnych obiektów \textit{ft::MenuItem} oraz generuje komunikat do systemu o wciœniêciu konkretnego przycisku w menu (MSG\_MENU\_ITEM\_SELECTED) dla wszystkich zarejestrowanych obiektów nas³uchuj¹cych. Ze wzglêdu na interakcjê przy pomocy klawiatury i myszy, korzysta z \textit{ft::InputManagera} przy obs³udze komunikatów z tych urz¹dzeñ.

\subsubsection{ft::VisualizationManager}
Centralny element zarz¹dzania elementami graficznymi sceny. Realizuje komunikacjê z pozosta³ymi niegraficznymi elementami systemu. Obiekt \textit{ft::VisualizationManager} jest odpowiedzialny za renderowanie wszystkich obiektów graficznych typu \textit{ft:SceneObject}, przy pomocy metody \textit{Render3DObjects}. Wszystkie obiekty, które maj¹ byæ automatycznie renderowane musz¹ byæ uprzednio zarejestrowane do renderowania metod¹ \textit{ft::VisualizationManager::AddObject}. 	

\subsubsection{ft::OGLContext}
Tworzy zawartoœæ renderowania (prymitywy graficzne) przy pomocy API OpenGL. Buduje wizualne, trwa³e elementy sceny (pod³oga, logo), korzysta z tekstur obiektu \textit{ft::TextureManager}.

\subsubsection{ft::Camera}
Tworzy cztery rodzaje kamer, oraz aktualizuje widok dla aktywnej kamery. Jest obiektem zarz¹dzanym ca³kowicie przez \textit{ft::CameraManager}. 

\subsection{ft::CameraManager}
Zarz¹dza realcjami pomiêdzy stworzonymi kamerami i obiektami sceny. Tworzy dla dowolnego obiektu sceny kamerê, której identyfikator odpowiada ID przypisanego obiektu sceny. Przetwarza komunikaty z klawiatury i myszy dotycz¹ce aktywnej kamery. Aktualizuje parametry bie¿¹cej kamery oraz widoku dla kontekstu rederowania \textit{ft::VisualizationManager}.  
\textit{ft::CameraManager} zarz¹dza kolekcj¹ kamer. Do podstawowych operacji nale¿y:
\begin{enumerate}
\item Prze³¹czanie bie¿¹cego widoku miêdzy zdefiniowanymi kamerami - klawisze \textbf{[} oraz \textbf{]}
\item Powiêkszenie obserwowanego fragmentu - klawisz \textbf{|}
\item Zmiana rodzaju bie¿¹cej kamery - klawisz \textbf{\textbackslash}
\end{enumerate}

Do prze³¹czania siê pomiêdzy zdefiniowanymi kamerami w systemie s³u¿¹ klawisze \textbf{[} oraz \textbf{]}. Opcja powiêkszenia (zoom) u³atwia obserwacjê szczegó³ów widoku. Zoom w³¹cza siê oraz wy³¹cza za pomoc¹ jednokrotnego wciœciêcia klawisza \textbf{|}. Zmiana rodzaju bie¿¹cej kamery nastêpuje po wciœniêciu klawisza. W systemie zdefiniowano 4 rodzaje kamer:
\begin{enumerate}
\item \textit{StaticCamera} - sztywna kamera bez mo¿liwoœci poruszania, pozwala tylko na statyczny widok z okreœlonego miejsca
\item \textit{SpringCamera} - kamera z pozycji trzeciej osoby. Pod¹¿a za celem i nie mo¿na ni¹ sterowaæ
\item \textit{FlyCamera} - kamera umo¿liwia przesuwanie widoku manualnie:
\begin{enumerate}
\item Do przodu - klawisz \textbf{w}.
\item Do ty³u - klawisz \textbf{s}.
\item W lewo - klawisz \textbf{a}.
\item W prawo - klawisz \textbf{s}.
\item W górê - klawisz \textbf{r}.
\item W dó³ - klawisz \textbf{f}.
\item Obrót o 360 stopni (odchylenie) - wciœniêty lewy klawisz myszy i przesuwanie jej w poziomie.
\item Obrót w zakresie +-90 stopni w górê i w dó³ od p³aszczyzny bie¿¹cego widoku (nachylenie) - wciœniêty lewy klawisz myszy i przesuwanie jej w pionie.
\end{enumerate}

\item \textit{TracingCamera} - kamera obraca siê wokó³ punktu celu.
\end{enumerate}

\subsection{Renderowanie Sprzêtowe}
Ka¿dy obiekt typu \textit{ft::SceneObject} mo¿e implementowaæ w³asne sprzêtowe renderowanie przy u¿yciu jêzyka assemblera ARB: \textit{ARB vertex program} oraz/lub \textit{ARB fragment program}. Aby zrealizowaæ sprzêtowe renderowanie wybranego obiektu nale¿y:
\begin{enumerate}
\item Utworzyæ pliki z kodem vertex shaderów i pixel shaderów dla fragmentów lub ca³ego obiektu graficznego w katalogu \textbf{shaders}. Shadery dla pixel shaderów (fragmentów programy) powinny mieæ rozszerzenie \textit{.frag} natomiast dla vertex shaderów (vertex programy) \textit{.vert}.
\item Utworzyæ w kodzie obiektu graficznego metody do inicjalizacji i wczytywania shaderów oraz rezerwacji pamiêci, analogicznie do metod \textit{Avatar::InitHardwareAcceleration} i \textit{Avatar::loadBufferObject}.
\item Utworzyæ w kodzie obiektu graficznego metodê renderuj¹c¹ obiekt przy pomocy sprzêtu analogiczn¹ do \textit{Avatar::HardwareRenderModelMesh}
\end{enumerate}


\flushright

\end{document}

